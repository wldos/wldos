/*
 * Copyright (c) 2020 - 2025 yuanxiyuzhou. All rights reserved.
 * Created by 元悉宇宙 (306991142@qq.com)
 * Licensed under the Apache License, Version 2.0 or a commercial license.
 * For Apache License Version 2.0 see License in the project root for license information.
 * For commercial licenses see term.md or contact 306991142@qq.com
 */

package com.wldos.framework.config;

import java.io.File;
import java.util.Arrays;
import java.util.List;
import java.util.Set;

import com.wldos.common.enums.FileAccessPolicyEnum;
import lombok.extern.slf4j.Slf4j;

import org.springframework.cloud.context.environment.EnvironmentChangeEvent;
import org.springframework.context.ApplicationListener;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.env.ConfigurableEnvironment;
import org.springframework.core.io.Resource;
import org.springframework.core.io.ResourceLoader;
import org.springframework.lang.NonNull;
import org.springframework.lang.Nullable;
import org.springframework.http.CacheControl;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
import org.springframework.web.servlet.resource.ResourceResolver;
import org.springframework.web.servlet.resource.ResourceResolverChain;

import javax.servlet.http.HttpServletRequest;

/**
 * 静态资源优化配置。
 * 
 * 针对桌面端外网图片库场景的性能优化：
 * 1. 精确匹配文件路径（/store/**、/oss/**），跳过 classpath 检查，直接访问文件系统
 * 2. 设置合适的缓存策略，减少重复请求
 * 3. 启用资源链缓存，提升性能
 * 4. 支持运行时配置刷新（通过监听 EnvironmentChangeEvent）
 * 
 * 性能优势：
 * - 避免顺序查找多个 classpath 路径（每个请求节省 4 次文件系统检查）
 * - 直接访问文件系统，减少中间层开销
 * - 缓存策略减少重复 I/O 操作
 * 
 * 运行时刷新：
 * - 监听 wldos_file_store_path 配置变化
 * - 配置刷新后，资源处理器会重新注册（通过重新初始化 WebMvcConfigurer）
 * 
 * @author 元悉宇宙
 * @date 2025/01/13
 * @version 1.0
 */
@Slf4j
//@Configuration
public class StaticResourceConfig implements WebMvcConfigurer, ApplicationListener<EnvironmentChangeEvent> {

	private final ConfigurableEnvironment env;
	private volatile String lastConfiguredPath;

	public StaticResourceConfig(ConfigurableEnvironment env) {
		this.env = env;
	}

	@Override
	public void addResourceHandlers(@NonNull ResourceHandlerRegistry registry) {
		registerResourceHandlers(registry);
	}

	/**
	 * 注册资源处理器的核心逻辑（可被重复调用以支持运行时刷新）
	 */
	private void registerResourceHandlers(ResourceHandlerRegistry registry) {
		// 从 Environment 中获取配置（支持动态刷新）
		// 优先从 Environment 获取，如果未配置则使用默认约定路径
		String fileStorePath = env.getProperty("wldos_file_store_path");
		
		// 如果未配置路径，使用默认约定路径
		if (fileStorePath == null || fileStorePath.isEmpty()) {
			File temp = new File(System.getProperty("wldos.platform.root"));
			File parentDir = temp.getParentFile();
			fileStorePath = parentDir != null ? parentDir.getAbsolutePath() : "";
		}

		if (fileStorePath.isEmpty()) {
			log.warn("wldos_file_store_path 未配置，跳过静态资源优化配置");
			return;
		}

		// 检查路径是否变化（避免重复注册）
		if (fileStorePath.equals(lastConfiguredPath)) {
			log.debug("静态资源路径未变化，跳过重新注册: {}", fileStorePath);
			return;
		}

		// 确保路径以 / 结尾（file: URL 要求）
		String basePath = fileStorePath.endsWith(File.separator) 
			? fileStorePath 
			: fileStorePath + File.separator;

		// 为每个文件访问策略配置精确的资源处理器
		// 这样 /store/** 和 /oss/** 请求会直接映射到文件系统，跳过 classpath 检查
		Arrays.stream(FileAccessPolicyEnum.values()).forEach(policy -> {
			String pathPrefix = policy.toString(); // "store" 或 "oss"
			String resourcePath = basePath + pathPrefix;
			
			// 使用 file: 前缀，支持跨平台路径
			// Windows: file:C:/path/to/store
			// Linux/Mac: file:/path/to/store
			String fileUrl = "file:" + resourcePath.replace("\\", "/");
			
			// 配置资源处理器：优先使用文件系统，如果找不到则回退到 classpath
			// 这样既能支持文件系统的动态路径，又能访问 WAR 包内的静态资源
			registry.addResourceHandler("/" + pathPrefix + "/**")
				.addResourceLocations(
					fileUrl + "/",  // 优先：文件系统路径（支持动态配置）
					"classpath:/META-INF/resources/" + pathPrefix + "/",  // 后备：WAR 包内资源
					"classpath:/resources/" + pathPrefix + "/",
					"classpath:/static/" + pathPrefix + "/",
					"classpath:/public/" + pathPrefix + "/"
				)
				// 设置缓存策略：30分钟（与 application-desktop.properties 中的配置一致）
				.setCacheControl(CacheControl.maxAge(1800, java.util.concurrent.TimeUnit.SECONDS))
				// 启用资源链缓存，提升性能
				.resourceChain(true)
				// 添加自定义 ResourceResolver，支持运行时配置刷新
				.addResolver(new DynamicPathResourceResolver(env, pathPrefix));
			
			log.info("配置静态资源处理器: /{}/** -> {}", pathPrefix, fileUrl);
		});

		lastConfiguredPath = fileStorePath;
		log.info("静态资源优化配置完成，文件存储父目录路径: {}", fileStorePath);
	}

	/**
	 * 监听配置变化事件，支持运行时刷新
	 * 
	 * 通过自定义 ResourceResolver（DynamicPathResourceResolver），
	 * 每次请求都会从 Environment 读取最新的 wldos_file_store_path 配置，
	 * 因此支持真正的运行时刷新，无需重启应用。
	 */
	@Override
	public void onApplicationEvent(@NonNull EnvironmentChangeEvent event) {
		Set<String> changedKeys = event.getKeys();
		
		// 检查 wldos_file_store_path 是否变化
		if (changedKeys.contains("wldos_file_store_path")) {
			String newPath = env.getProperty("wldos_file_store_path");
			log.info("检测到 wldos_file_store_path 配置变化: {} -> {}，将在下次请求时生效", lastConfiguredPath, newPath);
			lastConfiguredPath = null; // 清除缓存，标记配置已更新
		}
	}

	/**
	 * 动态路径资源解析器
	 * 
	 * 每次请求都从 Environment 读取最新的 wldos_file_store_path 配置，
	 * 实现真正的运行时配置刷新支持。
	 */
	private static class DynamicPathResourceResolver implements ResourceResolver {
		private final ConfigurableEnvironment env;
		private final String pathPrefix;

		public DynamicPathResourceResolver(ConfigurableEnvironment env, String pathPrefix) {
			this.env = env;
			this.pathPrefix = pathPrefix;
		}

		@Override
		@Nullable
		public Resource resolveResource(@Nullable HttpServletRequest request,
										@NonNull String requestPath, @NonNull List<? extends Resource> locations,
										@NonNull ResourceResolverChain chain) {
			// 每次请求都从 Environment 读取最新配置
			String fileStorePath = env.getProperty("wldos_file_store_path");
			
			// 如果未配置，使用默认约定路径
			if (fileStorePath == null || fileStorePath.isEmpty()) {
				File temp = new File(System.getProperty("wldos.platform.root"));
				File parentDir = temp.getParentFile();
				fileStorePath = parentDir != null ? parentDir.getAbsolutePath() : "";
			}

			// 优先尝试文件系统路径（支持动态配置）
			if (!fileStorePath.isEmpty()) {
				String basePath = fileStorePath.endsWith(File.separator) 
					? fileStorePath 
					: fileStorePath + File.separator;
				String resourcePath = basePath + pathPrefix;
				String fileUrl = "file:" + resourcePath.replace("\\", "/");
				
				// 创建新的 Resource 位置
				try {
					ResourceLoader resourceLoader = 
						new org.springframework.core.io.DefaultResourceLoader();
					Resource resource = 
						resourceLoader.getResource(fileUrl + "/" + requestPath);
					
					if (resource.exists() && resource.isReadable()) {
						return resource;
					}
				} catch (Exception e) {
					// 忽略异常，继续使用默认解析链（会查找 classpath）
				}
			}
			
			// 如果文件系统找不到，回退到默认解析链（会按顺序查找所有 locations，包括 classpath）
			// 这样既能支持文件系统的动态路径，又能访问 WAR 包内的静态资源
			return chain.resolveResource(request, requestPath, locations);
		}

		@Override
		@Nullable
		public String resolveUrlPath(@NonNull String resourcePath, 
				@NonNull java.util.List<? extends Resource> locations, 
				@NonNull ResourceResolverChain chain) {
			// URL 路径解析也使用动态路径
			return chain.resolveUrlPath(resourcePath, locations);
		}
	}
}

